###   帧缓冲

作用？为了解决什么问题？语法反而是次要的。

初始化GLFW的时候，OpenGL默认提供了帧缓冲，包括模板缓冲，深度缓冲，颜色缓冲，如果不指定帧缓冲的话，一个rendering pass的结果会写入到默认的帧缓冲中，包括模板信息，深度信息和颜色信息。

OpenGL向用户提供了自定义的帧缓冲，同样包括模板缓冲，深度缓冲，以及颜色缓冲，在一个rendering pass中，如果绑定的是自定义的帧缓冲，rendering的结果会写入到用户自定义的帧缓冲中。由于并不是默认的帧缓冲，实际上向自定义的帧缓冲中写入内容并不会影响屏幕显示的结果，只有默认帧缓冲的内容会显示到屏幕上，因此绑定自定义帧缓冲的时候，一个rendering pass 也被称为离屏渲染。

帧缓冲实际上是GPU中显存的一片区域，声明的帧缓冲时实际上时并不complete的，想要指定显存区域来存储模板信息，深度信息以及颜色信息，OpenGL 提供了两种附件形式：texture 以及render buffer object. 也就是需要生成texture 或者是 render buffer object来绑定到帧缓冲上面。

帧缓冲至少需要满足以下条件：

1. 附加至少一个缓冲
2. 附加至少一个附件
3. 所有附件必须是完整的，保留了内存
4. 每个缓冲都应该有相同的样本数

texture : 实际上就是texture ,可以在后续中作为一个纹理绑定到纹理单元上，并通过sampler进行采样。

render buffer object : 将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。也就是不需要在后续的使用的信息一般都作为render buffer object,比如模板缓冲和深度缓冲。

综上，frame buffer允许我们自定义帧缓冲，其中包括了模板缓冲，深度缓冲，颜色缓冲(都是作为附件绑定到帧缓冲上的，可以理解为得在显存上生成纹理或者render buffer object在绑定到帧缓冲上)，在rendering pass中绑定自定义的帧缓冲那么该pass 中的所有结果都会被写入到自定义的缓冲中，需要再次使用的信息可以写入到texture中以便后续使用。

帧缓冲的一个应用：后期处理。先把颜色信息渲染到自定义的帧缓冲的颜色缓冲中，其中颜色缓冲定义为texture.再在屏幕上渲染一个四边形，对texture进行采样并render，如果没有做任何处理实际上和直接rendering结果并没有不同，但是可以对采样的texel进行后处理。后处理为什么不能直接在默认的帧缓冲上面实现，比如fragment shader 中计算颜色时直接做后处理，反相可以直接1-color啊。这种简单的情况当然可以啊，但是如果是卷积核呢？fragment shader怎么获取周围像素的颜色？